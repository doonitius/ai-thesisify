QUANTUM RANDOM WALK ON A NUMBER LINE IMPLEMENTATION ON 
DIFFERENT SIMULATORS WITH WALL- TIME BENCHMARKING 

Since a cl assical computer has a limitation to solve a large size of data and complex 
problems, researchers have be en trying to find new solutions. Q uantum computing is one 
of them. A number of quantum algorithms have been invented. Some of them were 
theoretically proved that they could solve problems faster than their classical versions. 
According to the literature review, a quantum random walk has various advantages. 
Moreover, it can be a tool to construct other quantum algorithms. In this thesis, the one -
dimensional quantum random walk is studied. Then, the quantum random walk circuit is 
implemented. Forest from Rigetti and Qiskit from IBM, which are quantum programming 
platforms, are explored. Two experiments are conducted. First, the circuits are examined 
on quantum computer simulators from IBM and Rigetti. The sizes of the circuits are 4, 5, 
6, and 7- qubits position state s. For each size, the circuit is constructed with 5 different 
types of shift operators. The results show that computing wall -time from IBMâ€™s qua ntum 
computer simulator is significantly lower than Rigettiâ€™s quantum computer simulator for 
the same size and circuit type. Moreover, on the same circuit type, a positive linear 
relationship between the computing wall -time and the circuit depth is presented. Second, 
the same circuit sizes and types from the first experiment were deployed on an actual 
IBM quantum computer, named ibmq_16_melbourne . However, the returned result is 
only for the 4- qubit position state. The other sizes of position state s return error due to 
the capacity of the quantum computer. Furthermore, the returned measurement results are 
disturbed by the noise from the operation of the actual quantum computer . 
 
Circuit D epth/ Computing Wall -Time/  Quantum Random W alk/ Quantum 
Computer Simulator  

 CHAPTER 1 INTRODUCTION  
 
 
In this chapter, we give an introduction to  the thesis. First, a brief description of the thesis, 
including an addressed issue, related works from a quantum  random walk , the 
significance of the study, and an experimental method , is described . Second, four thesis 
objectives are illustrated. Last, we clarify the scope of study, including a selected 
algorithm, quantum computing platforms, and significant parameters.  
 
1.1 Statement of the Problem  
According to Mooreâ€™s Law, the number of transistors on an integrated circuit will doubly 
increase every two years  [1]. The trend seemed to be consistent with the law until several 
years ago. The computing power from classical computers is reaching its limit because 
the size of transistors integrated into a circuit is close to the atomic size of silicon. Some  
researchers have been t rying to solve this problem. Hassan , et al. [2] stated that there are 
other computing technologies, including optical computing / com puters, molecular 
computing / computers, DNA computing / computers, and quantum computing / 
computers. Since 1998, several quantum computers have been developed using various 
qubit technologies such as Superconducting qubit, Trapped ion qubit, and Photonic  qubit 
[3]. According to Quantum Computing Report [3], the superconducting qubit is the most 
widely adopted qubit technology. More importantly, the superconducting qubit is suitable 
for la rge scale integration of the quantum computer [4] . The superconducting material 
exhibits superconductivity properties at very low temperatures. With the benefit of 
superconducting qubit technologies, a variety of companies and organizations maintained 
the quantum computing devices based on this technology. Both IBM and Rigetti construct 
their quantum computers using the superconducting qubits technology. Both of them 
provide a quantum computer simulator and a channel to interact with their quantum 
computers. However, different quantum computer simulators and provided f rameworks 
might affect experimental results and other variables of the computation . 
 
Among the numerous quantum computer technologies that have been researched, 
quantum algorithms have been proposed to perform quantum computati on. The 
â€œQuantum Algorithm Zo oâ€ [5] website presents  a collection of quantum algorithms in 
multiple categories. Many quantum algorithms have been  proven to have better 
performance than classical algorithms [6] . The Quantum random walk is an interesting 
tool that  can also be used to construct other quantum algorithms [7] . For instance, t o find 
ğ‘˜ğ‘˜ equal numbers from the list of given ğ‘€ğ‘€ elements , the element distinctness algorithm 
[8] uses the quantum random walk to move among the formulated Hamming gr aph 
vertices and perform a check algorithm. Quantum random walk can be categorized into 
discrete and continuous quantum random walks. Both types have been broadly adopted 
by several researchers. The discrete quantum random walk algorithms can be applied to  
various kinds of problems. Roy , et al. [9]  developed a quantum algorit hm using the 2 
 
 
 discrete quantum random walk to solve a clustering problem. The results show that the 
the proposed algorithm speeds up exponentially over existing classical algorithms. In 
addition, the continuous quantum walk can be employed in multiple algor ithms. Muklen, 
et al. [10]  constructed an algorithm that travels among the vertices on a one -dimensional 
ring with additional bounds, using the cont inuous quantum walk. They showed that the 
traveling among the vertices can be faster than classical algorithm when provided 
appropriated additional bounds .  
 
According to Venegas -Andraca [11], a book described the quantum random walk from 
the computer scientist's perspective. Also, it demonstrated the advantage of the study on 
a one -dimensional quantum random walk on the line with the following three reasons. 
Firstly, the one -dimensional quantum random walk on the line can be used to formulate 
a walk on more complex graphs such as a circle or general graph. Secondly, the one -
dimensional quantum random walk on the line can be a simple model to study the 
quantum random walk properties, which will have a positive impact on a quantum 
algorithm construction. Thirdly, the one -dimensional quantum random walk on the line 
can be a quantumness testing tool for quantum computing devices .  
 
In this thesis, we study a model of a one -dimensi onal quantum random walk. Quantum 
computing circuits are implemented and tested on quantum computer simulators from 
IBM and Rigetti. Then, the results and computing wall -time (which is the time spent only 
in the quantum simulator computation excluding the communication and SDKâ€™s compile 
time) of the two quantum computer simulators are compared.  The effect of the different 
architectures is also inspected. Moreover, the relationship between the circuit depth and 
the computing wall -time is studied.  In conduct ing this study, it was assumed that the 
computing wall -time depends on the circuit depth. For IBM â€™s quantum   computer 
simulator, computing wall- time is extracted from the return value after execution. For the 
Rigetti, computing wall- time is acquired from a  simulatorâ€™s log. The circuit depth can be 
computed by counting the highest number of gates that apply on the same qubit and 
counting the gate that has to perform before. For example, the function wi ll return 9 for 
the circuit in f igure 1.1. However, the c ircuit depth can be acquired from IBMâ€™s depth()  
function. 
 
 
Figure 1.1 Example quantum circuit  
3 
 
 
 Experiments on the real quantum computer are also conducted. To find the real quantum 
computer's capability, similar circuits from the simulators will be computed on the real 
quantum computer from IBM as Rigettiâ€™s quantum computer cannot be accessed. The 
probability distributions are then collected . 
 
1.2 Objectives  
1. To study the discrete quantum random walk. 
2. To study programming on different quantum computers . 
3. To stud y the effect and performance of the different quantum computer architectures  
upon implementation of a one -dimensional quantum random walk.  
4. To study the relation ship between computing wall -time and circuit depth of  one-
dimensional quantum random walk circui ts. 
 
1.3 Scope  
In this thesis, the one -dimensional  quantum random walk is  studied. The quantum circuit s 
are developed and implemented on the quantum computer  and quantum computer 
simulators  using software development kits provided by IBM and Rigetti . The computing 
wall-time and circuit depth  of the quantum circuits tested on the different quantum 
computers simulators are  scrutinized . 
 
The rest of this thesis is organized as follows: Chapter 2 presents the basic of  quantum 
computing and quantum computer programm ing from IBM and Rigetti. Chapter 3 gives 
a simple explanation of the classical random walk and describes  the one -dimensional 
quantum random walk. The demonstration of the shift operator and circuit 
implementation are provided in Chapter 4. Chapter 5 conta ins experiments on our 
quantum circuits, including 5 sizes of one -dimensional quantum random walk and the 
investigation on the Multi -Control Toffoli function. Lastly, we offer our conclusion in 
Chapter 6.   CHAPTER 2 BACKGROUND STUDY ON QUANTUM 
COMPUTING  
 
 
In this chapter, we introduce three subjects of background knowledge. First, we briefly 
introduce quantum mechanics, including  qubits, quantum entanglement , and quantum 
measurement. Second, we describe quantum gates and circuits. Last, we explain two 
quant um computers (from IBM and Rigetti) including their architecture and resources for 
programming . 
 
2.1 Quantum Mechanics  
While data in classical computing is represented by a series of bits, a set of qubits is used 
in quantum computing. A classical bit can represent only one of two possible values at a 
time ( either  0 or 1), but a qubit can represent the two values at the same time .  
 
A state of a qubit can be denoted by a Ket notation, â€œ |âŸ©â€. Therefore, the qubit in state 0 
and 1 is represented by |0âŸ© and |1âŸ©, respectively . The state that a qubit contains two 
possible values at the same time, called â€œsuperpositionâ€, is shown in (2.1)  
 
 |Î¨âŸ©=ğ›¼ğ›¼|0âŸ©+ğ›½ğ›½|1âŸ© (2.1)  
 
where Î¨ denotes any qubit state. ğ›¼ğ›¼ and ğ›½ğ›½ can be arbitrary complex numbers, but they 
must  satisfy |ğ›¼ğ›¼|2+|ğ›½ğ›½|2=1. The state of the qubit can also be represented by matrix 
notation as follows : 
 
 
|0âŸ©=ï¿½1
0ï¿½ and |1âŸ©=ï¿½0
1ï¿½ (2.2) 
 
Information in a qubit can be processed by a unitary operator  that performs a unitary 
transformation . The unitary operator ğ‘ˆğ‘ˆ must  satisfy  the following propert y: 
 
 
ğ‘ˆğ‘ˆğ‘ˆğ‘ˆâ€ =ğ‘ˆğ‘ˆâ€ ğ‘ˆğ‘ˆ=ğ¼ğ¼, (2.3) 
 
where ğ¼ğ¼ is an identity matrix and ğ‘ˆğ‘ˆâ€  is a transpose complex conjugate of  ğ‘ˆğ‘ˆ . 
 5 
 
 
 Equation 2.5 presents a unitary transformation on a qubit, where  ğ‘ˆğ‘ˆ is a unitary ma trix of 
the one -qubit quantum operator . 
 |Î¨âŸ©â†’ğ‘ˆğ‘ˆ|Î¨âŸ©=ï¿½ğ‘ˆğ‘ˆ00ğ‘ˆğ‘ˆ01
ğ‘ˆğ‘ˆ10ğ‘ˆğ‘ˆ11ï¿½ï¿½ğ›¼ğ›¼
ğ›½ğ›½ï¿½=ï¿½ğ‘ˆğ‘ˆ00ğ›¼ğ›¼+ğ‘ˆğ‘ˆ01ğ›½ğ›½
ğ‘ˆğ‘ˆ10ğ›¼ğ›¼+ğ‘ˆğ‘ˆ11ğ›½ğ›½ï¿½ (2.5) 
 
To oper ate more than one qubit, dimensions  of the unitary matrix  can be increased by a 
tensor product  as shown in (2.6) .  
 
|Î¨1Î¨2âŸ©= |Î¨1âŸ©â¨‚|Î¨2âŸ©=ğ›¼ğ›¼1ğ›¼ğ›¼2|00âŸ©+ğ›½ğ›½1ğ›¼ğ›¼2|10âŸ©+ğ›¼ğ›¼1ğ›½ğ›½2|01âŸ©+ğ›½ğ›½1ğ›½ğ›½2|00âŸ© (2.6) 
 
Quantum entanglement is one of the most significant quantum phenomena. When two or 
more qubit s are entangled, the state of qubits cannot be specified separately. However, 
the quantum entanglement proper ty is not used in this thesis. Equation 2.7 shows an 
example of the two entangled qubits :  
 
 |Î¨ğ´ğ´âŸ©=1
âˆš2(|01âŸ©âˆ’|10âŸ©) 
|Î¨ğµğµâŸ©=1
âˆš2(|01âŸ©+|10âŸ©) 
|Î¨ğ‘ğ‘âŸ©=1
âˆš2(|00âŸ©âˆ’|11âŸ©) 
|Î¨ğ·ğ·âŸ©=1
âˆš2(|00âŸ©+|11âŸ©) 
 (2.7)  
 
Quantum measurement is a process of  readout  information from the quantum state. When 
a qubit , in (2.1) , is measured, for example, the superposition state |Î¨âŸ© will be collapsed 
to eith er 0 with probability |ğ›¼ğ›¼|2or 1 with probability |ğ›½ğ›½|2. The result of the measurement 
is then a classical bit of information, 0 or 1. In measurement, { |0âŸ©,|1âŸ©} is used as a 
measurement basis. To measure multiple qubits, the measurement basis need ed to be 
defined. If { |00âŸ©, |10âŸ©, |01âŸ©,|11âŸ©} is our measurement basis for the two joint qubits, four 
possible outcomes will be given with  probabilities |ğ›¼ğ›¼1ğ›¼ğ›¼2|2, |ğ›½ğ›½1ğ›¼ğ›¼2|2, |ğ›¼ğ›¼1ğ›½ğ›½2|2 and 
|ğ›½ğ›½1ğ›½ğ›½2|2, respectivel y. Therefore, the measurement of n - multiple qubits will result in 2ğ‘›ğ‘› 
possible outcomes. 
 
2.2 Quantum Circuits  
Classical gates such as AND , OR, and NOT  are used to implement a classical computation 
circuit.  Similarly, quantum gates are also used to co nstruct a quantum circuit. The  
quantum gates are unitary transformation ğ‘ˆğ‘ˆ  that can be described by unitary matri ces.  
 6 
 
 
 The Hadamard gate corresponds to Hadamard transformation  that produces the 
superposition state from the computational basis. If the comp utational basis is {|0âŸ©,|1âŸ©}, 
applying Hadamard to |0âŸ© and |1âŸ© will transf orm the state to 1
âˆš2(|0âŸ©+|1âŸ©), and 
1
âˆš2(|0âŸ©âˆ’|1âŸ©), respectively.  
 
The set of Pauli operator s includes  Pauli -I, Pauli -X, Pauli -Y, and Pauli -Z. Pauli -I is the 
identity transformation represent ed by the identity matrix. Pauli- X or a bit-flip operator  
will map |0âŸ© to |1âŸ© and |1âŸ© to |0âŸ©. Pauli -Z or a phase flip operator  will change the phase 
of the qubit state  from  |1âŸ© to -|1âŸ©, but it  does  nothing to |0âŸ©. Pauli -Y is a combination of 
Pauli -X and Pauli -Z. The n, Pauli -Y performs a bit-flip and phase -shift that maps |0âŸ© to 
ğ‘–ğ‘–|1âŸ© and |1âŸ© to âˆ’ğ‘–ğ‘–|0âŸ©. 
 
The r otation operators are a set of parameterized single- qubit operators. The set of 
rotation operators includes ğ‘…ğ‘…ğ‘¥ğ‘¥(ğœƒğœƒ), ğ‘…ğ‘…ğ‘¦ğ‘¦(ğœƒğœƒ), and ğ‘…ğ‘…ğ‘§ğ‘§(ğœƒğœƒ) that rotates around the x, y, and z 
axis, respectively, on a Bloch sphere.  The angle ğœƒğœƒ must be given to specify a rotation 
angle . It can be positive or negative but must be in radians. 
 
Regarding two -qubit gates, the CNOT  or controlled- NOT  gate operates on two qubits. 
One qubit, called a control qubit, controls the operati on, while another is a target qubit. 
If the state of the control qubit is |1âŸ©, the target qubit will be flipped. The control phase 
gate is a two -qubit gate that the target qubit makes a change when the control qubit is |1âŸ©;  
the operating is that done to the target qubit is a phase manipulation. The swap gate is 
also a two -qubit gate that swaps the state of the two qubits. The gate maps |01âŸ© to |10âŸ© 
and |10âŸ© to |01âŸ©.  
 
The Toffoli gate is a 3-qubit quantum gate. Like CNOT , the 3 operated qubits can be 
separated into control and target qubit s. Two qubits are the control qubit s and the other 
is the target qubit.  The target qubit is flipped when all control qubits are in the state |1âŸ©. 
Otherwise, the Toffoli gate does nothing .  
 
Quantum gat e can b e represented  in graphical notation and matrix, as illustrated in Table 
2.1. The quantum circuit can be constructed by assigning any quant um gate to qubits. As 
shown in f igure 2.1, Hadamard and CNOT  are assigned to 2 qubits. The circuit creates 
entanglemen t between the two -qubits.  
 
 
 7 
 
 
 Table 2.1 Commonly used quantum gates  
 
Gate name  Graphical notation  Unitary Matrix representation  
Hadamard gate  
 1
âˆš2ï¿½1 1
1âˆ’1ï¿½ 
Pauli -X or NOT gate  
 ï¿½01
10ï¿½ 
S gate  
 ï¿½10
0ğ‘–ğ‘–ï¿½ 
CNOT Gat e 
 ï¿½1000
0
0
00
0
10
1
01
0
0ï¿½ 
Toffoli  Gate  
 
â£â¢â¢â¢â¢â¢â¢â¡10
0100
00
00
0010
0000
0000
00
00
0000
01
00
0000
00
00
0000
0110
0100
00
00
0010
00â¦â¥â¥â¥â¥â¥â¥â¤
 
 
 
Figure  2.1 Quantum circuit for creating a maximally entangled two -qubit state  
 
2.3 Quantum Processing Unit  and Programming 
Several techniques can be used to construct a quantum computer, such as Optical [12], 
trapped ions [13-15], and superconducting qubit. Superconducting qubit technology is 
widely adopted by many large companies such as Intel, Google, IBM, and Rigetti. Some 
of them have published documents and have made computing services available for 
public use and research. Among the available super conducting qubit quantum computers, 
IBM and Rigetti were selected to be studied in this thesis for 3 main reasons. Firstly, both 
companies have actual quantum computers. Secondly, the same quantum circuit can 
compute on simulators and real quantum computers of both companies. Thirdly, their 
quantum computing platforms are provided with all pertinent documents .  
 
 
8 
 
 
 2.3.1 IBM  
 
IBM is one of the major companies that has been intensively involved in the field of 
quantum computing. According to quantum computing devices [16], IBM has five 
quantum computers and one quantum simulator. Both  can be operated with open quantum 
assembly language (openQASM) [17]. Their 4 quantum computers that are open to access 
contain 5 and 16 qubits. The other 20- qubit quantum computer is only for IBMâ€™s clients. 
In superconducting qubit technol ogy, the qubit is controlled by conducting microwave 
pulses. The connection of qubits is subjected to a coplanar waveguide (CPW) resonator 
for readout and control. CPW is a transmission line that can transfer microwave -
frequency signals .  
 
To apply a circu it of quantum gates, the system has a limitation on a physical quantum 
computer. As shown in Figures 2.2 and 2.3, IBM [18 -19] the arrows connected between 
qubit nodes indicate the frequency signal of a qubit. An arrow is pointing from a higher 
frequency qubit to a lower frequency qubit. The difference in frequency produces the 
limitation of deploying quantum gates. IBM suggested that using a higher frequency bit 
as a controlled bit can prevent the inverse of the operation. For example, if we want to 
deploy the CNOT gate to the quantum computer in Figure 2.3, the qubit at position 0 
should be used as a control qubit while the qubit at position 1 can be a target. However, 
the quantum circuit setup will be managed and optimized by the framework. 
 
 
Figure 2.2 coupling map of IBM 16 -qubits  
 
 
 
Figure 2.3 coupling map of IBM 5 -qubits  
 
IBM provides a software development kit (SDK) called Quantum Information Software 
Kit ( Qiskit). Qiskit is an open- source framework that communicates between quantum 
computer s and quantum program s. The programming  language used for communicating 
with Qiskit can be Python, JavaScript, and swift. In this thesis, we use Python language.  
 
9 
 
 
 Qiskit consists of  four parts : Terra, Aqua, Ignis , and Aer . Each of them  is responsible for 
different  jobs as follows .  
1. Terra is the foundation of the framework. The input of Terra is  in a level of circuit 
and pulses. Terra will optimize the input due to the constraint of the physical 
quantum processor and will also manage the execution.   
2. Aqua is an element  that contains a library of several quantum algorithms and  
multiple  extensions such as Qiskit Optimization, Qiskit Chemistry, and Qiskit 
Finance.   
3. Ignis is designed to understand and mitigate noise in quantum circuits and 
devices. It also has tools to m easure noise parameters, and to generate and analyze 
the circuits . 
4. Aer is the high -performance simulator framework. It helps Terra to optimize and 
comply with circuits . It can  also perform a realistic noise simulation from   
quantum computer noise  models . 
In order to use  Python with Qiskit (which is similar to writing a regular Python program) 
the related libraries have to be imported. The following list presents the primary Qiskit 
libraries . 
1. QuantumRegister  defines  a number of the required qubit s.  
2. Classica lRegister  defines a number of the required classical bit s.  
3. QuantumCircuit  is for a circuit construction with the parameter s from 
QuantumRegister  and ClassicalRegister . The collection s of quantum gates are 
bundled with QuantumCircuit .  
4. Aer uses for a quant um computer simulator selection. 3 simulators, namely 
Qasm_simulator , Statevector , and Unitary are available.  
- Qasm_simulator  simulates multiple  shots of quantum computation on the 
circuit and returns counts. The noise model of the quantum computer backend 
can be applied to the Qasm_simulator  for the computation under the specific 
noise behavior.  
- Statevector  provides a single -shot execution of the circuit and returns a final 
state vector.  
- Unitary  also provides a single -shot execution. The result of the Uni tary 
simulator is the unitary matrix of the circuit.  
5. Execute is a function for quantum circuit execution.  
Figure 2.4 presents an example source code of the quantum circuit implementation with 
Qiskit. After importing the libraries  (lines 1-4), a quantum circuit can be constructed by 
adding  quantum gate s to the QuantumCircuit  variables  (lines 10-13). To compute  the 
circuit, a simulator has  to be selected . In this example, Qasm_simulator  is chosen to 
simulate a quantum computation.  
 
2.3.2 Rigetti  
Rigetti, wh ich is another company involved in the field of quantum computing, aims to 
provide quantum cloud services. Currently, Rigetti has two operating quantum devices, 10 
 
 
 8-qubit and 16- qubit [20]. Similar to IBM, Rigettiâ€™s devices are also constructed with 
superconducting technology, but are different in the topology as shown in Figure 2.5. 
 
 
Figure 2. 4 Quantum circuit for the establishment of entanglement between   
2 qubit s with Qiskit  
 
 
Figure 2.5 The connectivity  (topology)  of 16 qubits Aspen- 1 QPU 
 
Forest is Rigettiâ€™s  SDK for the communicat ion between the quantum processing unit 
(QPU) and Quil [21]. Different from QISKit, Rigetti adopts Quil programming language. 
The Forest SDK did not separate into elements like QISKit, but it has three essential 
components.  
1. PyQuil is a Python library that helps to construct a Python program with Quil 
programming language .  
2. Quil compiler is responsible for translating Quil into the instruction code that can 
operate with any Rigetti quantum machine . 
3. The quantum virtual machine  can simulate a quantum computer and execute Quil 
on a classical computer.  
11 
 
 
 To program with Forest, the major libraries , including  Program , get_qc , and set of 
quantum gates , have to be imported.  
1. Program  contain s a list of instructions to compose a quantum  program such as a 
quantum gate concatenation, classical bit declaration, a measurement, and 
running shot specification.  
2. The get_qc  function is responsible for selecting a quantum computer or specif ying 
the size and topology of the quantum computer simula tor.  
3. For a set of quantum gates, unlike Qiskit, the required quantum gate s should be 
specified  separately.  A quantum circuit can be construct ed by concatenating 
quantum gates into the  Program â€™s variables .  
To compute a quantum circuit, Quil compiler (Quil c) and quantum virtual machine 
(QVM) have to start. Quil compiler and QVM operate as a computing server for their 
task. Because of the quantum gate limitation on the quantum computer, the set of quantum 
gates in the circuit has to be complied with the gate  that able to operate on a quantum 
computer or simulator. QVM, then, computes the compiled version of the quantum circuit 
from Quilc and returns the measurement result of each shot to the program. Figure 2.6 
presents the source code of a quantum circuit im plementation with PyQuil. After 
importing the libraries (lines 1 -2), a variable p is declared as a space for quantum gates 
(line 3). A classical register is then declared (line 4). The quantum circuit is constructed 
by adding quantum gates (lines 6 â€“ 10). The number of measurement shots is set to 10 
(line 11). Since this program requires 2 qubits, the 2- qubit quantum computer simulator 
2q-qvm is selected (line 13 ).  
 
Both IBM and Rigetti quantum computers support a common quantum gate set as 
follows:  
1. Pauli gates including Pauli- I, Pauli -X, Pauli -Y, and Pauli -Z 
2. Hadamard gate  
3. Toffoli gate  
4. Phase gates  
5. Control phase gate  
6. Controlled X gate  
7. Swap gate  
As mentioned above, both IBM and Rigetti provide a quantum computer simulator. 
However, the operating techniques of  the two platforms are different.  Qasm_simulator  
operates on C++, but QVM  operates on LISP. In addition to their default configuration, 
multiple elements in Qasm_simulator  and QVM  are configurable. In this thesis, only the 
default configuration is used. 12 
 
 
  
Figure 2.6 Quantum circuit for the establishment of entanglement between  
2 qubits with PyQuil  
LaRose  [22] compared the quantum computing resources from big companies in the 
quantum computing area, including Microsoft, Rigetti, IBM, and ProjectQ. His work 
described the softwar e library support, quantum hardware, quantum compiler, and  
simulator performance. The list of quantum algorithms, which were added to each 
companyâ€™s software library, was as well presented. IBMQX5  from IBM and Agave  from 
Rigetti, which were the largest pub licly available quantum computers at that time, were 
selected for discussion. Regarding the actual quantum computers, each quantum 
computer has a basic set of quantum gates and connectivity. The quantum compiler is an 
operator that compiles program source code into a quantum circuit for a specific quantum 
computer and simulator. Again, only compilers from IBM and Rigetti were discussed. 
The discussion indicated that the two platforms have a different basic set of gates. IBMâ€™s 
quantum computer supports ğ‘ˆğ‘ˆ 1, ğ‘ˆğ‘ˆ2, ğ‘ˆğ‘ˆ3, and CNOT  while Rigetttiâ€™s quantum computer 
supports ğ‘…ğ‘…ğ‘¥ğ‘¥, ğ‘…ğ‘…ğ‘§ğ‘§, and Controlled- Z (CZ) . Finally, this research compared the performance 
of quantum computer simulators from IBM and ProjectQ. A state vector simulator from 
IBM and C++ simulator from ProjectQ were chosen. The comparison described the 
performance of circuit depth, the number of qubits, and computing wall -time. Unlike that 
work, this thesis compares circuit depth and computing wall -time between 
Qasm_simulator  from IBM and QVM  from Rigetti. The quantum circuits depend on the 
type and size of the one -dimensional quantum random walk. 
13 
 
 
 2.4 IBM Single Qubit Gate a nd Multi -Control Toffoli Function  
According to  Y. Aharonov [23] , the IBM quantum computing platform operates on the 
implementation of a Controlled -NOT gate and three parameter ized single -qubit gates , 
including  ğ‘ˆğ‘ˆ1, ğ‘ˆğ‘ˆ2 and ğ‘ˆğ‘ˆ3. The ğ‘ˆğ‘ˆ1 gate is a one-parameter gate. The parameter can be 
assign ed to the gate by ğ‘ˆğ‘ˆ1(ğœ†ğœ†). An operation of ğ‘ˆğ‘ˆ1 is equivalent to the rotatio n gate ğ‘…ğ‘… ğ‘§ğ‘§(ğœ†ğœ†). 
ğ‘ˆğ‘ˆ2 is a two-parameter gate. The parameter s can be assi gned  to the gate by ğ‘ˆğ‘ˆ2(ğœ™ğœ™,ğœ†ğœ†). An 
operation of ğ‘ˆğ‘ˆ2 is equivalent to the set of rotation gate ğ‘…ğ‘… ğ‘§ğ‘§(ğœ™ğœ™+ğœ‹ğœ‹
2)ğ‘…ğ‘…ğ‘¥ğ‘¥(ğœ‹ğœ‹
2)ğ‘…ğ‘…ğ‘§ğ‘§(ğœ†ğœ†âˆ’ğœ‹ğœ‹
2). ğ‘ˆğ‘ˆ3 is 
a three -parameter gate. The parameters for ğ‘ˆğ‘ˆ3 includes  ğœƒğœƒ, ğœ™ğœ™, and ğœ†ğœ† that can be assigne d 
to the gate by ğ‘ˆğ‘ˆ3(ğœƒğœƒ,ğœ™ğœ™,ğœ†ğœ†). An operation of ğ‘ˆğ‘ˆ3 gate is equivalent to the set of rotation gate 
ğ‘…ğ‘…ğ‘§ğ‘§(ğœ™ğœ™+3ğœ‹ğœ‹)ğ‘…ğ‘…ğ‘¥ğ‘¥(ğœ‹ğœ‹
2)ğ‘…ğ‘…ğ‘§ğ‘§(ğœƒğœƒ+ğœ‹ğœ‹)ğ‘…ğ‘…ğ‘¥ğ‘¥(ğœ‹ğœ‹
2)ğ‘…ğ‘…ğ‘§ğ‘§(ğœ†ğœ†). A major differen ce among these three gates is 
how the  microwave pulse  is applie d. ğ‘ˆğ‘ˆ1 can change a phase of qubit without apply ing 
any pulses.  The ğ‘ˆğ‘ˆ2 gate appli es single ğœ‹ğœ‹
2 pulse. For ğ‘ˆğ‘ˆ 3, two ğœ‹ğœ‹
2 pulses are applied for making 
an operation. However, both of ğ‘ˆğ‘ˆ 1and ğ‘ˆğ‘ˆ2 can be convert ed into the ğ‘ˆğ‘ˆ3 gate as fo llows.   
ğ‘ˆğ‘ˆ1(ğœ†ğœ†)âˆ¶=ğ‘ˆğ‘ˆ3(0,0,ğœ†ğœ†)      (2.8) 
ğ‘ˆğ‘ˆ2(ğœ™ğœ™,ğœ†ğœ†)âˆ¶=ğ‘ˆğ‘ˆ3(ğœ‹ğœ‹
2,ğœ™ğœ™,ğœ†ğœ†)    (2.9) 
Besides , any single -qubit gate can  also be transformed into ğ‘ˆğ‘ˆ 3. For example:  
ğ‘ƒğ‘ƒğ‘ğ‘ğ‘ƒğ‘ƒğ‘ƒğ‘ƒğ‘–ğ‘–âˆ’ğ‘‹ğ‘‹ âˆ¶=ğ‘ˆğ‘ˆ3(ğœ‹ğœ‹,0,ğœ‹ğœ‹)               (2. 10) 
ğ»ğ»ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ğ»ğ»ğ‘ğ‘ğ»ğ»ğ‘ğ‘ âˆ¶=ğ‘ˆğ‘ˆ3(ğœ‹ğœ‹
2,0,ğœ‹ğœ‹)               (2.11)  
ğ‘†ğ‘† ğ‘”ğ‘”ğ‘ğ‘ğ‘”ğ‘”ğ‘”ğ‘” âˆ¶=ğ‘ˆğ‘ˆ3(0,0,ğœ‹ğœ‹
2)                (2. 12) 
Moreover, Qiskit offers a useful function named multi -controlled- Toffoli (MCT). The 
MCT function works as applying the Toffoli operation with multiple control qubits. MCT 
consists of four main parameters: a list of control qubits, the target qubit, a list of ancilla, 
and mode of use. The modes of use in the MCT function are basic, basic -dirty -ancilla, 
advanced, and no- ancilla. The different modes require different numbers of ancilla. After 
applying the function, the set of quantum operations will be generated based on the 
selected mode and input parameters.  
For the basic mode, four main parameters must be determined. A member of ancillaâ€™s list 
must be |0âŸ©. The number of ancillae must be equal to ğ‘¥ğ‘¥ âˆ’2, where ğ‘¥ğ‘¥ is the number of 
control qubits. The MCT with basic mode will generate a circuit that consists of ğ‘ˆğ‘ˆ1, ğ‘ˆğ‘ˆ2, 
ğ¶ğ¶ğ¶ğ¶ğ¶ğ¶ğ¶ğ¶  and ğ¶ğ¶ğ‘‡ğ‘‡ğ‘‡ğ‘‡ğ‘‡ğ‘‡ğ‘‡ğ‘‡ğ‘ƒğ‘ƒğ‘–ğ‘–  gate, as shown in Figure 2.7.  
For the basic- dirty -ancilla mode, t he required parameters are similar to the basic mode. 
However, a state of ancilla is not necessary to be |0âŸ©. The number of required ancilla is 
still similar to the basic mode. The applying of MCT with basic mode will generate a 
circuit that consists of ğ‘ˆğ‘ˆ 1, ğ‘ˆğ‘ˆ2, and ğ¶ğ¶ğ¶ğ¶ğ¶ğ¶ğ¶ğ¶  gate, as illustrated in Figure 2.8.  
 14 
 
 
  
Figure 2.7 MCT -basic with ğ‘ğ‘ 00,ğ‘ğ‘01,ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘  ğ‘ğ‘02 as control qubits, ğ‘ğ‘ 03 as an 
ancilla, and ğ‘ğ‘04  as a target qubit  
 
Figure 2.8 MCT - basic- dirty -ancilla  with ğ‘ğ‘10,ğ‘ğ‘11,ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘  ğ‘ğ‘12 as control qubits, 
ğ‘ğ‘13 as an ancilla, and ğ‘ğ‘14  as a target qubit  (the second part of the 
circuit is continued from the first part)  
In the advanced mode, the required number of parameters remains four. However, the 
number of ancilla  qubits will be ğ‘¥ğ‘¥ âˆ’4, where ğ‘¥ğ‘¥ is the number of control qubits. Still, the 
state of ancilla doesnâ€™t have to be |0âŸ©. The application of MCT  with basic mode will 
generate a circuit that consists of ğ»ğ»ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ğ»ğ»ğ‘ğ‘ğ»ğ»ğ‘ğ‘, ğ¶ğ¶ğ‘‡ğ‘‡ğ‘ğ‘ğ‘”ğ‘”ğ»ğ»ğ‘‡ğ‘‡ğ‘ƒğ‘ƒğ‘ƒğ‘ƒğ‘”ğ‘”ğ‘ğ‘ âˆ’ğ‘ˆğ‘ˆ1, and CNOT ga te, as 
displayed in Figure 2.9.  
 
Figure 2.9 MCT -advanced with ğ‘ğ‘ 20,ğ‘ğ‘21,ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘  ğ‘ğ‘22 as control qubits, ğ‘ğ‘ 23 as an 
ancilla, and ğ‘ğ‘24  as a target qubit  
 
With the no- ancilla mode, the required number of parameters decreases to three. As the 
name of the mode, this mode requires zero ancillae. Then, the remaining three parameters 
include a list of control qubits, the target qubit, and the mode of use. The (application / 
15 
 
 
 applying) of MCT with basic mode will generate a circuit that consists of ğ»ğ» ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ğ»ğ»ğ‘ğ‘ğ»ğ»ğ‘ğ‘, 
ğ‘ˆğ‘ˆ1, and CNOT gate, as shown in Figure  2.10.  
 
Figure 2. 10 MCT - no-ancilla  with ğ‘ğ‘ 30,ğ‘ğ‘31,ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘  ğ‘ğ‘32 as control qubits, ğ‘ğ‘ 33 as 
an ancilla, and ğ‘ğ‘34  as a target qubit (the second part of the circuit is 
continued from the first part)
  CHAPTER 3 QUANTUM RANDOM WALKS  
 
 
This chapter introduces the one -dimensional quantum random walk.  The concept of 
quantum random walk and the  relevant research literature are reviewed. Subsequently, 
the one -dimensional quantum random walk i s focused. Main operators and quantum state 
evolution are lastly presented . 
 
3.1 Quantum Random Walk  
A quantum  random walk is a quantum computing version of a classical random walk. 
The quantum random walk can be classified into two categories: discrete -time quantum 
random walk and continuous -time quantum random walk. According to Venegas -
Andraca [11], the main difference between  the two categories is the times at which 
evolution operators are applied. The evolution operator is a set of operators that applies 
change to the system of quantum random walk. Details of the evolution operator will later 
be described in this section. The evolution operators are applied in discrete ti me steps in 
a discrete quantum random walk, while it can be applied anytime in a continuous quantum 
random walk.  
 
The concept of the quantum random walk was first introduced in 1993 by Aharonov, et 
al.[23]. They also demonstrated that, wi th the nature of quantum characteristics, the 
average length of the walking path on a line can be longer than the length a classical 
random walk can produce. This quantum random walk algorithm was later considered a 
discrete model.  After this work, the quantum random walk has gained more attention. 
Kempe [24] overviewed the development of quantum walks for quantum computing. The 
work described both discrete and continuous quantum random walks and compared them 
to a classical random walk. Her work also  presented the physical quantum random walk 
implementation point of view. Lovett , et al. [25]  implemented  a universal quantum 
computation gate from the discrete quantum random walk algorithm. They also proved 
that both continuous and discrete quantum random walks  could be efficiently used to 
simulate other quantum algorithms .  
 
This thesis focuses only on the  discrete quantum random walk on a one -dimensional 
graph. The main structure of the discrete quantum random walk consists of  a walker, a 
coin, and the evolution operators. Similar to the classical random walk, a walker walks 
on the graph. The possible walking paths are the concatenated vertices and edges. The 
coin is a state that is considered a decision -maker space. The next step of the walk to any 
of the concatenated vertices and edges can be determined by the coin state. The evolution 
operators can be separated into two parts, including coin and shift operators. The coin 
operator is a function that operates the coin state. Similarly, the shift operation operates 
the state of the walker.  The shift operator considers the change of the walker state from 17 
 
 
 the coin state that was manipulated by the coin operator.  The two operations are 
repeatedly operated without performing a measurement. The measurement is only 
performed at the final position of the walking process. Figure 3.1 displays the flowchart 
of the disc rete quantum random walk on the one -dimensional graph.  
 
 
Figure 3.1 One-dimensional quantum random walk 
The entire state of the quantum  walk  ğ»ğ» consists of two Hilbert spaces, ğ»ğ»ğ‘ğ‘and ğ»ğ»ğ‘ğ‘, in the 
Hilbert space that ğ»ğ»=ğ»ğ»ğ‘ğ‘âŠ—ğ»ğ»ğ‘ğ‘ , where ğ»ğ»ğ‘ğ‘ represents the Hilbert space of the walkerâ€™s 
position state and ğ»ğ» ğ‘ğ‘ represents the Hilbert space for the coin state.  
 
The walker is a quantum state that occupies a space ğ»ğ» ğ‘ğ‘. The ğ»ğ»ğ‘ğ‘ spanned with basis  |ğ‘–ğ‘–âŸ©ğ‘ğ‘ 
where ğ‘–ğ‘– is a position on  the one -dimensional graph (the number line). To initialize the 
position, the origin of the walker is usually at position zero on the number line that can 
be represented as  |0âŸ©ğ‘ğ‘. The coin state basis, however, can be spanned by { |0âŸ©ğ‘ğ‘, |1âŸ©ğ‘ğ‘}, in 
which the number of basis is equal to the number of edges connected to the vertex in the 
number line . 
 
The application sequence of the evolution operators on each step of the walk is a coin 
operator followed by a conditional shift operator. In our  experiments, the coin operator 
is performed using the Hadamard gate that transforms the coin state into a superposition 
of its state,  as shown in the following equations .  
18 
 
 
 ğ¶ğ¶( |0âŸ©ğ‘ğ‘)â†’1
âˆš2( |0âŸ©ğ‘ğ‘+ |1âŸ©ğ‘ğ‘)     (3.1)  
ğ¶ğ¶( |1âŸ©ğ‘ğ‘)â†’1
âˆš2( |0âŸ©ğ‘ğ‘âˆ’ |1âŸ©ğ‘ğ‘)     (3.2)  
where Cis the coin operator. 
Next, the conditional shift operator operates based on the state of coin space, which could 
be defined as:  
ğ‘†ğ‘†( |0âŸ©ğ‘ğ‘âŠ—|ğ‘–ğ‘–âŸ©ğ‘ğ‘)âŸ¶ |0âŸ©ğ‘ğ‘âŠ—|ğ‘–ğ‘–+1âŸ©ğ‘ğ‘   (3.3) 
ğ‘†ğ‘†( |1âŸ©ğ‘ğ‘âŠ—|ğ‘–ğ‘–âŸ©ğ‘ğ‘)âŸ¶ |1âŸ©ğ‘ğ‘âŠ—|ğ‘–ğ‘–âˆ’1âŸ©ğ‘ğ‘   (3.4)  
where Sis the conditional shift operator.  
Accordingly, Equation 3.5 presents the evolution operators on one step of the walk.  
ğ‘ˆğ‘ˆ=ğ‘†ğ‘†(ğ¶ğ¶âŠ—ğ¼ğ¼ğ‘ğ‘)    (3.5)  
where ğ‘ˆğ‘ˆ is the evolution operators of the one -dimensional quantum random walk, ğ‘†ğ‘†  
represents the conditional shift operator, ğ¶ğ¶  represents the coin operator, and  ğ¼ğ¼  represents 
the vector space of the position state. The tensor operator âŠ— is used to state that ğ¶ğ¶  applies 
only the coin state without direct action to the position state. For example, if the walk 
start with  |Î¨âŸ©0=|0âŸ©ğ‘ğ‘âŠ—|0âŸ©ğ‘ğ‘, two walking step with Hadamard as a coin operator can 
be derived as follows : 
 |Î¨âŸ©1=ğ‘ˆğ‘ˆ(|0âŸ©ğ‘ğ‘âŠ—|0âŸ©ğ‘ğ‘)    (3.6)  
 |Î¨âŸ©1=ğ‘†ğ‘†ï¿½1
âˆš2( |0âŸ©ğ‘ğ‘+ |1âŸ©ğ‘ğ‘)âŠ—|0âŸ©ğ‘ğ‘ï¿½   (3.7)  
 |Î¨âŸ©1=1
âˆš2 |0âŸ©ğ‘ğ‘|1âŸ©ğ‘ğ‘+1
âˆš2 |1âŸ©ğ‘ğ‘|âˆ’1âŸ©ğ‘ğ‘    (3.8)  
 |Î¨âŸ©2=ğ‘†ğ‘†ï¿½1
âˆš2ï¿½1
âˆš2( |0âŸ©ğ‘ğ‘+ |1âŸ©ğ‘ğ‘)ï¿½|1âŸ©ğ‘ğ‘+1
âˆš2ï¿½1
âˆš2( |0âŸ©ğ‘ğ‘âˆ’ |1âŸ©ğ‘ğ‘)ï¿½|âˆ’1âŸ©ğ‘ğ‘ï¿½ (3.9)  
 |Î¨âŸ©2=1
2 |0âŸ©ğ‘ğ‘|2âŸ©ğ‘ğ‘+1
2 |1âŸ©ğ‘ğ‘|0âŸ©ğ‘ğ‘+1
2 |0âŸ©ğ‘ğ‘|0âŸ©ğ‘ğ‘âˆ’1
2 |1âŸ©ğ‘ğ‘|âˆ’2âŸ©ğ‘ğ‘            (3.10)    CHAPTER 4 SHIFT OPERATOR FOR QUANTUM RANDOM  
WALK  
 
 
In the one -dimensional quantum random  walk, the shift operator  is a key function that 
manipulates the walkerâ€™s position state to go forward or backward according to the 
condition of the coin state. In this chapter, we firstly describe a family of quantum 
incrementer circuits derived by Li, et al. [26]. After that, we design a shift operator circuit 
based on the idea of Li. Lastly, we verify the implementation of our designed shift 
operator circuit.  
 
4.1  Incrementer Circuits  
Li, et al. [2 6] introduced the first quantum incrementer circuit with the notation (ğ‘ğ‘:0) 
where n denotes the number of qubits, as shown in Figure 4.1. The operation of the 
incrementer is to increment the value of the input state by one.  The gates presented in 
the figure are the control -flip gates where the â€œ âŠ•â€ signs represent the target qubit, and 
the black dots represent the control qubits. The target qubit will be flipped if every 
quantum state of the connected black- dot is |1âŸ©. 
 
 
Figure 4.1  n -qubit incrementer  
 
They also gave an example of a simple three- qubit incrementer circuit, as displayed in 
Figure 4.2. After passing through the circuit, the input qubits |ğ´ğ´2ğ´ğ´1ğ´ğ´0âŸ© become 
ï¿½ğ´ğ´2+ğ´ğ´1+ğ´ğ´0+ï¿½. The state of ï¿½ ğ´ğ´2+ğ´ğ´1+ğ´ğ´0+ï¿½ is obtained from Equations (4.1) -(4.3) where 
â€œÂ¬â€, â€œ*â€, and â€œ+â€ represent Boolean logic NOT, AND, and XOR gates, respectively. The 
results of all possible three -qubit states are displayed in Table 4.1.  
ğ´ğ´2+=ğ´ğ´2+ğ´ğ´1âˆ—ğ´ğ´0      (4.1)  
ğ´ğ´1+=ğ´ğ´1+ğ´ğ´0     (4.2)  
ğ´ğ´0+=Â¬ğ´ğ´0       (4.3)  
 
20 
 
 
  
Figure 4.2 A three -qubit incrementer gate  
 
Table 4.1 The truth table of the three -qubit incrementer circuit  
 
Input  |000âŸ© |001âŸ© |010âŸ© |011âŸ© |100âŸ© |101âŸ© |110âŸ© |111âŸ© 
Output  |001âŸ© |010âŸ© |011âŸ© |100âŸ© |101âŸ© |110âŸ© |111âŸ© |000âŸ© 
 
The quantum gate with more than two- control qubits, however, does not exist in the 
common quantum computing operators. Thus, they generalized the incrementer ( ğ‘ğ‘:0)  
circuit into two circuit types, namely  (ğ‘ğ‘:ğ‘ğ‘âˆ’1:ğ‘…ğ‘…ğ‘…ğ‘…) and  (ğ‘ğ‘:ğ‘ğ‘âˆ’1:ğ‘…ğ‘…ğ‘…ğ‘…), that are 
constructed from the standard quantum computing gates, including NOT, CNOT, and 
Toffoli gates. Note that for the notion ( ğ¶ğ¶:ğ‘€ğ‘€:ğ‘…ğ‘…ğ‘…ğ‘…/ğ‘…ğ‘…ğ‘…ğ‘… ): ğ¶ğ¶ denotes the number of  qubits, 
ğ‘€ğ‘€ denotes  the number of carrying bits, and ğ‘…ğ‘…ğ‘…ğ‘… /ğ‘…ğ‘…ğ‘…ğ‘… denotes the enabled/disabled reset 
carry qubit . 
 
The (ğ‘ğ‘:ğ‘ğ‘âˆ’1:ğ‘…ğ‘…ğ‘…ğ‘…) circuit is generalized from the ( ğ‘ğ‘:0) circuit using the â€œfull ancilla 
qubitsâ€ technique. The main idea of this technique is to add one ancilla qubit between 
every two control qubits. For the four -qubit incrementer circuit as an example, Figure 4.3 
illustrates the ( ğ‘ğ‘:0)  circuit where ğ‘ğ‘=4 that consists of, from left to right, three -control -
not, Toffoli, CNOT, and NOT gates. Fi gure 4.4 presents the reconstructions of the four -
qubit incrementer circuit for the  ( ğ‘ğ‘:ğ‘ğ‘âˆ’1:ğ‘…ğ‘…ğ‘…ğ‘…)  notation using only Toffoli, CNOT, and 
NOT gates. It can be seen in the figure that the input qubits |ğ´ğ´3ğ´ğ´2ğ´ğ´1ğ´ğ´0âŸ© become 
â€œï¿½ğ´ğ´3+ğ´ğ´2+ğ´ğ´1+ğ´ğ´0+ï¿½â€ where ğ¶ğ¶ ğ‘–ğ‘– represents the ancilla qubit with ğ‘–ğ‘–=0,1,2. However, due 
to the unitary properties of quantum gates, the two adjacent mirror -images quantum gates 
can be canceled out. The final circuit after the cancelation is then shown in Figure 4.5.  
 
  
Figure 4.3 Four-qubits incrementer circuit with notation (n:0)  
21 
 
 
  
Figure 4.4 Four -qubits incrementer circuit reconstruction with Toffoli, 
CNOT and NOT gates  
 
Figure 4.5 Four -qubits incrementer circuit w ith notation (n:n- 1:RE) after 
reducing two equivalent adjacent quantum gates  
 
The ancilla qubits in the ( ğ‘ğ‘:ğ‘ğ‘âˆ’1: ğ‘…ğ‘…ğ‘…ğ‘…) circuit will always be reset to |0âŸ© after being 
transformed by CNOT or Toffoli gates. However, the ancilla qubits in the (ğ‘ğ‘:ğ‘ğ‘âˆ’1: ğ‘…ğ‘…ğ‘…ğ‘…) 
circuit will not be reset. The four -qubit incrementer circuit with the ( ğ‘ğ‘:ğ‘ğ‘âˆ’1: ğ‘…ğ‘…ğ‘…ğ‘…) 
notation is shown in Figure 4.6.  
 
 
Figure 4.6 Four -qubits incrementer circuit with notation (n:n -1: RD)  
 
22 
 
 
 According to X. Li , et al. [26], the comparison between the three notations was presented, 
as shown in Table 4.2.  
Table 4.2 The comparison among the notation 
 
Type of the circuits  (ğ‘ğ‘:0) (ğ‘ğ‘:ğ‘ğ‘âˆ’1:ğ‘…ğ‘…ğ‘…ğ‘…) (ğ‘ğ‘:ğ‘ğ‘âˆ’1:ğ‘…ğ‘…ğ‘…ğ‘…) Before reduce  reduced  
Amount of gates  n 2n 32nâˆ’ 21nâˆ’ 
Number of 
carried(ancilla) 
qubits  0 1nâˆ’ 1nâˆ’ 1nâˆ’ 
Time Complexity  N/A 2()On  ()On  ()On  
 
In addition, Li , et al. [26]  briefly mentioned a decrementer circuit that was constructed 
from the multiple -control -not gates as displayed in Figure 4.7. The target qubits at the       
â€œâŠ•â€ sign will be flipped when the qubits state at all connected white dots is 0.   
 
 
Figure 4.7  n -qubit decrementer circuit  
 
4.2  A Design of Shift Operator for Quantum Rand om Walk  
In accordance with the incrementer and decrementer design presented by X. Li , et al. 
[26], in this section we present the construction of the shift operator with the properties 
of forward, backward, and conditional operator . 
 
In order to build the forward, our proposed incrementor is newly designed based on the 
idea of the incrementor with the notation (ğ‘ğ‘:ğ‘ğ‘âˆ’1: ğ‘…ğ‘…ğ‘…ğ‘…). However, there are three main 
differences between our design and the incrementor with the notation (ğ‘ğ‘:ğ‘ğ‘âˆ’1: ğ‘…ğ‘…ğ‘…ğ‘…). 
Firstly, in our design, the first 3 qubits can be placed next to each other without having 
an ancilla qubit in between. Sec ondly, the number of required ancilla will only be 
increased when the number of qubits is more than three. Thirdly, the number of required 
gates were less than the previous approach. The comparison between our approach 
ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘  (ğ‘ğ‘:ğ‘ğ‘âˆ’1: ğ‘…ğ‘…ğ‘…ğ‘…) is concluded i n Table 4.3. The incrementor circuit can be constructed 
as shown in Figure 4.8.  
23 
 
 
 Table 4.3 The comparison between increment er and incrementer in this thesis  
Type of the circuits  (ğ‘ğ‘:ğ‘ğ‘âˆ’1:ğ‘…ğ‘…ğ‘…ğ‘…) 
reduced  In this thesis  
Amount of gates  32nâˆ’ 36nâˆ’ 
Number of carried 
(ancilla) qubits  1nâˆ’ 3; 4nnâˆ’â‰¥  
0 otherwise  
Time Complexity  ()On  ()On  
 
 
 
Figure 4.8 Four -qubits incrementer  circuit  
 
For the backward, we apply a decrementer circuit to the shift operator. As shown in Figure 
4.7, the decrementer is the opposite of the incrementer circuit. However, adding the 
decrementer to the previous incrementer on the same circuits can generate a consider able 
depth of the circuit. The idea of the classical complement operator is then adopted.  
The classical complement operator can be classified into oneâ€™s complement and twoâ€™s 
complement. The oneâ€™s complement is the operation that inverts all bits in a bit string 
(turn 0s to 1s and vice versa). Twoâ€™s complement is the operator that performs oneâ€™s 
complement process and adds the output by one. Equations (4.4) -(4.9) describe an 
example of decrementing 0001 that should result in 0000:  
 X = 0001          (4.4)  
 Xâ€™1 complement = 1110       (4.5)  
 Xâ€™2 complement = Xâ€™1 complement +1    (4.6)  
 Xâ€™2 complement = 1110 +1       (4.7)  
 Xâ€™2 complement = 1111       (4.8)  
 If we oneâ€™s complement all bits again, the result will be 0000.  (4.9)  
As the twoâ€™s complement has an addition by one, it then can take advantage of our 
incrementor  circuit. For each of complement, we used the NOT gate that applies on all 
24 
 
 
 qubits. Then, the decrementer circuit can be constructed as shown in Figure 4.9. The gates 
in the red boxes are responsibl e for the complement operations . 
 
 
Figure 4.9 Four -qubits decrementer circuit  
 
Further, the additional  operation  is applied by replacing  the NOT gate in the complement 
operation with the CNOT gate where the coin qubit  is the control qubit . As 
aforementio ned, the shift operator of the quantum random walk will be operated based 
on the state of the coin. When the coin state is |0âŸ©, the condition of CNOT will not be 
applied and the shift circuit will operate only the increment. When the coin state is  |1âŸ©, 
on the other hand, the circuit operates the decrementer by initially flipping the target 
qubits, performing the increment, and eventually flipping the qubits again. Our design of 
the shift operator circuit is displayed in Figure 4.10, where ğ¶ğ¶ğ‘‡ğ‘‡ğ‘–ğ‘–ğ‘ğ‘  represents the coin state . 
 
Figure 4.10 The conditional shift operator for four -qubit state  
 
4.3  Shift Operator Circuit Verification  
To verify our design of the conditional shift operator in the previous section, the quantum 
random walk on the number line is s imulated. The probability distribution from the 
measured final position state will be compared with the probability distribution from [11]  
as shown in Figure 4.11.  
25 
 
 
  
Figure 4.11 The probability distribution of one -dimensional quantum random 
walk with Hadamard coin after 100 walks , starts at position 0  
 
As displayed in Figure 4.11, the walking space required at least 100 positions to the left 
and right of the starting point. The number line with possible 28 positions is then defined 
as shown in Figure 4.12. Thus, eight qubits of the position state are needed along with 
one qubit of the coin state. The experiment was run on the IBMâ€™s quantum computer 
simulator, â€œ Qasm_simulat or.â€  
Initially, the walker is placed at position 0 on the number line, which was mapped to the 
|01111111 âŸ©ğ‘ğ‘ position state , as shown in Figure 4.12. Figure 4.13 presents the initial 
setup of the walk, where the |01111111 âŸ©ğ‘ğ‘ position state can be mapped to the qubits as 
|ğ‘ğ‘7,ğ‘ğ‘6,ğ‘ğ‘5,ğ‘ğ‘4,ğ‘ğ‘3,ğ‘ğ‘2,ğ‘ğ‘1,ğ‘ğ‘0âŸ©ğ‘ğ‘. The set of NOT gates are applied on the specific qubits to 
initialize the starting point of the walker.  The ğ¶ğ¶0, ğ¶ğ¶1, ğ¶ğ¶2, ğ¶ğ¶3, and ğ¶ğ¶ 4 in Figure 4.13 are the 
carried or ancilla qubits. ğ¶ğ¶ğ‘‡ğ‘‡ğ‘–ğ‘–ğ‘ğ‘  represents space of coin state. The state of the coin is 
initiali zed with 1
âˆš2(|0âŸ©ğ‘ğ‘+ğ‘–ğ‘–|1âŸ©ğ‘ğ‘) because the compared distribution is  symmetric , as 
demonstrated in Figure 4.11.   
 
 
 
Figure 4.12 The number line with 82possible vertices  
The Hadamard gate is selected as an operation of a coin operator because of the two 
possible directions of the walk.  The shift operator is constructed from the design in 
section 4.2. However, the shift operator was scaled up from the example in Figure 4.10 
26 
 
 
 by adding more position states and ancilla. The circuit with Hadamard coin and shift 
operator is illustrated in Figure 4.14. During the execution, the coin and shift operators 
are repeatedly operated one- hundred times, which are equal to the number of walking 
steps.  
 
  
 
Figure 4.13 The initial set up o f walking with an eight- position state and one coin state  
 
 
Figure 4.14  The coin and condition shift operator for walking on the number line 
with eight- position states. The vertical dashed line separates the coin 
and the shift operator . 
 
27 
 
 
 Figure 4.15 prese nts the probability distribution of our circuit implementation. The 
probability distribution complies with the characteristic of probability distribution in the 
previous literature  [11] as shown in Figure 4.11. Thus, we can conclude that our 
conditional shift operator circuit can be used to simulate the one -dimensional quantum 
random walk.  
 
  
 
Figure 4.15 The probability distribution of one -dimensional quantum random 
walk with Hadamard coin after 100 walks starting from the 0 
position.  
  CHAPTER 5 EXPERIME NTAL RESULT AND DISCUSSION  
 
 
In this section, we present experiments of one -dimensional quantum random walk on 
quantum simulators and on the IBMâ€™s quantum computer. All of the experiments are 
conducted under the following environments:  
- Rigetti Quil Compile r (quilc) version 1.12.1  
- Rigetti Quantum Virtual Machine (QVM) version 1.12.0 
- IBM Qiskit 0.13.0 
o Qiskit- terra 0.10.0  
o Qiskit- aer 0.3.2  
- Python version 3.7.3  
- Ubuntu version 19.04 
- Virtual Machine Specification:  
o 3 CPU Cores  
o 4 GB of Memory  
- Virtual Box Version 6.0.10 
- Computer Specification:  
o CPU: Intel I5 -6400, 2.70 GHz  
o Memory: 16 GB, DDR 4 1066 MHz  
The one -dimensional quantum random walk circuits in the experiments consist of 3 main 
steps. Firstly, the initial walker and the coin state are set up. Secondly, the unitary operators, 
including coin and conditional shift operators, are placed with multiple trials depend on the 
number of walking steps. Lastly, the measurement operators are placed at the last operation 
of each qubit position state. For all of the experim ents, the coin state is always initialized 
with 1
âˆš2(|0âŸ©ğ‘ğ‘+ğ‘–ğ‘–|1âŸ©ğ‘ğ‘) using the  Hadamard and S gates .  
Two main experiments have been executed. First, the benchmarking of quantum computer 
simulators between IBMâ€™s Qasm_simulator  and Rigettiâ€™s QVM  using a one -dimensional 
quantum random walk. Both of the quant um computer simulators operate under their default 
configuration. Second, the execution of a one -dimensional quantum random walk on an 
actual quantum computer. 
 
5.1  A Benchmarking of Quantum Computer Simulators  
The benchmarking is tested on the quantum com puter simulators from IBM and Rigetti with 
4 different sizes, including 4, 5, 6, and 7 qubits position state, of the one -dimensional 
quantum random walk. For each size, 6 circuits are tested. 2 circuits are made of the 
common quantum gates from Qiskitâ€™s qa sm_simulator and Rigettiâ€™s QVM . The other 4 29 
 
 
 circuits are built using the 4 different modes of the Qiskitâ€™s Multi Control Toffoli function 
and compute only on Qasm_simulator . 
 
5.1.1 A Benchmarking on Four -qubit Quantum Random Walk  
For the four -qubit position state, a walker can walk along the 24=16 possible positions on 
the number line as displayed in Figure 5.1. Initially, the walker is placed at position 0 on the 
number line, which was mapped to the |0111âŒªğ‘ğ‘ position state. The walking step was set to 
7 due to the capacity of the number line. 6 qubits and 4 classical bits are used in this 
experiment. The position state uses 4 qubits, while the coin state uses 1 qubit. The last qubit 
is used for an ancilla in the shift operator. As shown in Figure 5.2, ğ‘ğ‘0,ğ‘ğ‘1,ğ‘ğ‘2 and ğ‘ğ‘3 represent 
the qubit for the position states, ğ¶ğ¶ğ‘‡ğ‘‡ğ‘–ğ‘–ğ‘ğ‘  represents the qubit for the coin, and ğ¶ğ¶0 represents an 
ancilla. For the initialization process, the NOT gates are ap plied to the ğ‘ğ‘0,ğ‘ğ‘1,  and ğ‘ğ‘2 qubits 
so that the initial position state becomes |0111âŒªğ‘ğ‘. The Hadamard  and S gates are applied 
to initial the coin state to 1
âˆš2(|0âŸ©ğ‘ğ‘+ğ‘–ğ‘–|1âŸ©ğ‘ğ‘). Figure. 5.3 illustrates the shift operator for 
walking on the four -qubit position state.  
 
 
 
Figure 5.1 The number line of a one -dimension quantum random walk with four 
qubits position state  
 
  
 
Figure 5.2 The initial set up of walking with a four -position state and one coin state  
30 
 
 
 The one -dimensional quantum random walk circuit is composed of the initialization gates, 
seven (as the maximum walking steps) sequential sets of the coin and shift operators, and 
the measurement operators. The measurement operators are only applied to the ğ‘ğ‘0,ğ‘ğ‘1,ğ‘ğ‘2 
and ğ‘ğ‘3 qubits at the very last step. In the modification with MCT, the MCT with 4 modes 
of operation will replace the circuit in the red square in Figure 5.3. The initialization and the 
measurement are still the same. To make a re asonable comparison, the walking process is 
performed 100,000 times on each quantum computer simulator. The computing wall -time, 
which is the time spent for the computation, is collected at every 1,000 measurement shots. 
Therefore, 100 computing wall -times  are kept.  
 
 
 
Figure 5.3 The conditional shift operator for four -qubit state and the position of 
MCT modification (in the square)  
 
 
Figure 5.4 The probability distributions of four -qubit position state one -
dimensional quantum random walk with 7 walking s teps 
00.20.4
-7-6-5-4 -3 -2 -1 0 1 2 3 4 5 67The Probablity distributions from four qubit position state one -
dimensional quantum random walk with 7 walking steps
Qiskit Common Gates Rigetti Common Gates
MCT-Basic MCT-Basic-Dirty-Ancilla
MCT-Advanced MCT-NoAncilla31 
 
 
 Figures 5.4 display the probability distributions of the measured results from the 100,000 
walking processes performed on the Qiskitâ€™s Qasm_simulator  and Rigettiâ€™s QVM using the 
quantum circuits with common gates and and Qiskitâ€™s with MCT functions. T he results from 
the measurements show that the probability distributions from the two quantum computer 
simulators and four -mode of MCT function are similar. Moreover, both probability 
distributions agree with the theory that the distribution should be symm etrically spread for 
this experimental setting. However, the computing wall -times on the two quantum computer 
simulators are significantly different, as shown in Table 5.1. The computing wall -time from 
the Qasm_simulator  is remarkably less than the wall -time from the QVM . The discussion 
on this issue will be given in Section 5.1.5.2. 
 
Table 5.1 The analysis of wall -time from running the quantum random walk on four -qubit 
position state on the number line between IBMâ€™s Qasm_simulator  and Rigettiâ€™s 
QVM  
 
 Commo n quantum gates  MCT  
 Qasm_simulator  QVM  Basic  Basic -
Dirty -
Ancilla  Advanced  NoAncilla  
Mean  0.093  11.395  0.166  0.239  0.207  0.291  
S.D. 0.004  0.856  0.012  0.0096  0.007  0.0094  
Median  0.092  11.051  0.162  0.237  0.206  0.288  
Circuit 
Depth  99 99 175 316 225 323 
Ancilla  1 1 1 1 0 0 
 
5.1.2 A Benchmarking on Five- qubit Quantum Random Walk  
In this experiment, the size of the position state is extended to five qubits. Figure 5.5 displays 
the number line with 25=32 walking positions. The maximum number of walking s teps is 
increased to 15 because of the number line expansion. The walker is, again, initialized at 
position 0 represented by the |01111âŒªğ‘ğ‘ position state. The coin state at initializing is 
1
âˆš2(|0âŸ©ğ‘ğ‘+ğ‘–ğ‘–|1âŸ©ğ‘ğ‘). This experiment requires 8 qubits, as shown in Figure 5.6, where 
ğ‘ğ‘0,ğ‘ğ‘1,ğ‘ğ‘2,ğ‘ğ‘3 and ğ‘ğ‘4 represent the position state, ğ¶ğ¶ğ‘‡ğ‘‡ğ‘–ğ‘–ğ‘ğ‘  represents the coin state, and ğ¶ğ¶0,ğ¶ğ¶1  
represent two ancilla qubits. The extra ancilla is required as the shift operator for the five -
qubit position state has to be redesigned. The shift operator for the four -qubit position state 
is expanded by adding one ancilla and multiple Toffoli gates, as demonstrated in Figure 5.7. 
In this experiment, the one -dimensional quantum random walk circui t for the five -qubit 
position state is composed of the initialization gates, fifteen duplicated sets of the coin and 32 
 
 
 shift operators, and the measurement operator at the end of the circuit. Again, the MCT with 
4 modes of operation will replace the circuit in the red square in Figure 5.7. The initialization 
and the measurement are still the same. In a similar manner, the walking process is executed 
100,000 times, and the computing wall -time is collected at every 1,000 measurement shots . 
 
 
 
Figure 5.5 T he nu mber line of a one -dimension quantum random walk with five 
qubits position state  
 
  
 
Figure 5.6  The initial set up of walking with a five -position state and one coin state  
 
 
 
Figure 5.7 The coin and condition shift operator for walking on the number line  with five -
position states; the vertical dashed line separates the coin and the shift 
operator  
33 
 
 
 Figures 5.8 displays the probability distributions of the measured results from the 100,000 
walking processes performed on the Qiskitâ€™s Qasm_simulator  and Rigett iâ€™s QVM using the 
quantum circuits with common gates and and Qiskitâ€™s with MCT functions. Same as the 
previous experiment,  the probability distributions from the two quantum computer 
simulators and four -mode of MCT functions are similar and are consistent  with the theory .  
The computing wall -times on the two quantum computer simulators, however, are different 
as shown in Table 5.2. The computing wall -time from the Qasm_simulator  is still less than 
the wall -time from the QVM . Moreover, according to further i nvestigation into the 
relationship between circuit depth and computing wall -time, it was found that the circuit 
composed of the MCT function with Advanced mode spent more computation time than the 
circuit MCT function with Basic -Dirty -Ancilla mode although  the Advanced mode has 
smaller circuit depth. More details on this issue will be discussed in Section 5.1.5.3.  
 
  
 
Figure 5.8 The probability distributions of five -qubit position state one -
dimensional quantum random walk with 15 walking steps  
 
 
00.050.10.150.20.25
-15 -13 -11 -9 -7 -5 -3-1 13579111315The Probability distributions from five qubit position state one -
dimensional quantum random walk with 15 walking steps
Qiskit Common Gates Rigetti Common Gates MCT-Basic
MCT-Basic-Dirty-Ancilla MCT-Advanced MCT-NoAncilla34 
 
 
 Table 5.2 The analysis of wall -time from running the quantum random walk on five -qubit 
position state on the number line between IBMâ€™s Qasm_simulator  and Rigettiâ€™s 
QVM  
 
 Common quantum gates  MCT 
 Qasm_simulator  QVM  Basic  Basic -
Dirty -
Ancilla  Advanced  NoAncilla  
Mea n 0.261  114.181  0.512  1.207  1.374  1.593  
S.D. 0.014  0.962  0.018  0.054  0.035  0.039  
Median  0.26 114.074  0.510  1.190  1.367  1.584  
Circuit 
Depth  270 270 885 1605 1380 1770 
Ancilla  2 2 2 2 0 0 
 
5.1.3 A Benchmarking on Six -qubit Quantum Random Walk  
In this ex periment, the position state is increased to six qubits. The space on the number line 
is also extended to 26 walking positions as shown in Figure 5.9. Then, The maximum 
number of walking steps is increased to 31. The walker starts on position 0 with the 
|011111âŒªğ‘ğ‘ position state . The initialization of the coin state is still 1
âˆš2(|0âŸ©ğ‘ğ‘+ğ‘–ğ‘–|1âŸ©ğ‘ğ‘). The 
total number of a required qubit is 10, including 6 qubits for the position state, 3 qubits for 
the ancilla, and 1 qubit for the coin. The init ialization of the circuit can be seen in Figure 
5.10 where  ğ‘ğ‘ 0,ğ‘ğ‘1,ğ‘ğ‘2,ğ‘ğ‘3,,ğ‘ğ‘4 and ğ‘ğ‘5 represent the position state, ğ¶ğ¶ğ‘‡ğ‘‡ğ‘–ğ‘–ğ‘ğ‘  represents the coin 
state, and ğ¶ğ¶ 0,ğ¶ğ¶1ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘  ğ¶ğ¶2  represent 3 ancilla qubits. Again, the shift oper ator for the six -
position state has to be redesigned by adding ancilla  ğ¶ğ¶ 2 and multiple Toffoli gates as 
illustrated in Figure 5.11. Similar to the previous experiments, the MCT with 4 modes of 
operation will replace the circuit in the red square in Fi gure 5.11. The initialization and the 
measurement are the same as before.  
 
 
 
Figure 5.9 T he number line of a one -dimension quantum random walk with six 
qubits  position state  
 
35 
 
 
   
 
Figure 5.10 The initial set up of walking with a six -position state and one  coin- state 
 
Figure 5.12 illustrates the probability distributions of the measured results from the 100,000 
walking processes performed on the Qiskitâ€™s Qasm_simulator  and Rigettiâ€™s QVM using the 
quantum circuits with common gates and and Qiskitâ€™s with MCT functions. Unsurprisingly, 
the results from the measurements show that the probability distributions from the two 
quantum computer simulators and four modes of MCT function are similar. Moreover, both 
probability distributions are consistent with the theor y. The computing wall -times on the 
two quantum computer simulators are still different, as shown in Table 5.3. The computing 
wall-time from the Qasm_simulator  is also less than the wall- time from the QVM .  
 
 
 
Figure 5.11 The coin and condition shift opera tor for walking on the number line with 
six-position states. The vertical dash line separated between coin and shift 
operator  
36 
 
 
  
 
 
Figure 5.12 The probability distributions of six -qubit position state one -dimensional 
quantum random walk with 31 walking steps  
 
Table 5.3 The analysis of wall -time from running the quantum random walk on six -qubit 
position state on the number line between IBMâ€™s Qasm_simulator  and Rigettiâ€™s 
QVM  
 
 Common quantum gates  MCT  
 Qasm_simulator  QVM  Basic  Basic -
Dirty -
Ancilla  Advanced  NoAncilla  
Mean  0.637  1617.956  1.369  4.234  5.107  7.473  
S.D. 0.021  38.484  0.064  0.162  0.198  0.186  
Median  0.633  1596.643  1.345  4.148  5.016  7.442  
Circuit 
Depth  682 682 3317  6108  4619  8370  
Ancilla  3 3 3 3 1 0 
 
00.020.040.060.080.10.120.14
-27
-25
-23
-21
-19
-17
-15
-13
-11
-9
-7
-5
-3
-1
1
3
5
7
9
11
13
15
17
19
21
23
25
27The Probability distributions from six qubit position state one -dimensional 
quantum random walk with 31 walking steps
Qiskit Common Gates Rigetti Common Gates MCT-Basic
MCT-Basic-Dirty-Ancilla MCT-Advanced MCT-NoAncilla37 
 
 
 5.1.4 A Benchmarking on Seven -qubit Quantum Random Walk  
In order to achieve robust experimental  results, the size of the examination circuit is 
increased to 7. With the extended size, the total position on the number line is escalated to 
27, as displayed in Figure 5.13. The number of walking steps i s 63. The walker starts at 
position 0 with the position state |0111111 âŒªğ‘ğ‘. The initial coin state is 1
âˆš2(|0âŸ©ğ‘ğ‘+ğ‘–ğ‘–|1âŸ©ğ‘ğ‘). The 
circuit is then constructed by 12 qubits, including 7 qubits -position- state, 4 qubits -ancilla, 
and 1 qubit -coin-state. The circuit initialization can be seen in Figure 5.14, 
ğ‘ğ‘0,ğ‘ğ‘1,ğ‘ğ‘2,ğ‘ğ‘3,ğ‘ğ‘4,ğ‘ğ‘5 and ğ‘ğ‘6 represent the position states; ğ¶ğ¶ğ‘‡ğ‘‡ğ‘–ğ‘–ğ‘ğ‘  represents the coin state; and 
ğ¶ğ¶0,ğ¶ğ¶1,ğ¶ğ¶2ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘  ğ¶ğ¶3  represent 4 the Ancilla qubits. Again, 4 modes of MCT function will 
replac the quantum gate in the red rectangular as illustrated in Figure  5.15.  
 
 
 
Figure 5. 13 The number line of a one -dimension quantum random walk with 
seven qubits  position state  
 
 
 
Figure 5.14 The initial set up of walking with a seven -position state and one coin- state 
38 
 
 
  
 
Figure 5.15 The coin and condition shift operator for walking on the number line with 
seven -position states. The vertical dash line separates the coin from the shift 
operator  
 
Figure 5.16 displays t he probability distributions of the measured results from the 100,000 
walking processes performed on the Qiskitâ€™s Qasm_simulator  and Rigettiâ€™s QVM using the 
quantum circuits with common gates and and Qiskitâ€™s with MCT functions. Like the 
previous 3 sizes, the probability distributions from the two quantum computer simulators 
and 4 MCT function modes  are similar. Furthermore, the characteristic of the distribution is 
symmetrically spread from the starting point. Still, the computing wall- time between IBM 
and Rigetti quantum computer simulator is different.  
 
Figure 5.16 The probability distributions of seven- qubit position state one -dimensional 
quantum random walk with 63 walking steps  
00.050.1
-51
-47
-43
-39
-35
-31
-27
-23
-19
-15
-11
-7
-3
1
5
9
13
17
21
25
29
33
37
41
45
49The Probability distributions from seven qubit position state one -
dimensional quantum random walk with 63 walking steps
Qiskit Common Gates Rigetti Common Gates MCT-Basic
MCT-Basic-Dirty-Ancilla MCT-Advanced MCT-NoAncilla39 
 
 
 Table 5.4 The analysis of wall -time from running the quantum random walk on seven -
qubit position state on the number line between IBMâ€™s Qasm_simulator  and 
Rigettiâ€™s QVM  
 
 Common quantum gates  MCT  
 Qasm_simulator  QVM  Basic  Basic -
Dirty -
Ancilla  Advanced  NoAncilla  
Mean  1.42 10908.271  3.268  12.65  19.171  30.537  
S.D. 0.029  36.558  0.038 0.194  0.244  0.25 
Median  1.412  10913.062  3.261  12.605  19.155  30.535  
Circuit 
Depth  1641  1641  10650  19848  18840  36669  
Ancilla  4 4 4 4 2 0 
 
5.1.5 Experimental Discussion  
This section discusses the results from Section 5.1.1 -  5.1.4 based on 3 following points: the 
average probability distribution, the computing wall -time, and the relationship between the 
circuit depth and the computing wall -time.  
 
5.1.5.1 Probability Distribution  
Considering the position state with the same number of qubits, the probability distributions, 
as displayed in Figures 5.4, 5.8, 5.12, and 5.16, from different circuit implantations have 
similar trend. The probability distributions consistency proves that one -dimensional 
quantum random walk circuits, which are computed on Qiskit â€™s Qasm_simulator  and 
Rigettiâ€™s QVM , correspond to the theory in Section 3.2. However, peaks of the graph at the 
same position on the number line are slightly different, as shown in Figure 5.17. It might be 
assumed that the difference was occurred from a d eviation from the average measurement 
values . The different trials of measurement are then conducted for a further analysis. Two 
additional experiments with 50 and 150- thousand shots are computed and measured. The 
results show that the difference among pe aks still exists; the difference might due to the 
deviation.  
 
 
Figure 5.17 The peak of position - 43 from seven- qubit position state walk  
40 
 
 
 5.1.5.2 Computing wall -time (Qasm_simulator  vs QVM ) 
For the identical circuits computed on IBMâ€™s Qasm_simulator  and Rigettiâ€™s QVM , the 
computing wall -times are significantly distinct as illustrated in Figure 5.18. Note that the 
average computing wall -time from Qasm_simulator  and QVM  are shown, respectively, on 
the primary (left side) and secondary (right side) vert ical axes.  
 
Although the computing circuits are equivalent, the computing architectures of the two 
simulators are dissimilar. Both quantum computer simulators need to be analyzed. 
Unfortunately, both simulator are displayed with a binary file format, which is human 
unreadble file. Therefore, the detail of a circuit execution cannot be received by the source 
code analysis. We then try to study program documents from both simulators. However, the 
documents are not described in the detail of the circuit execut ion. Hence, resource utilization 
are inspected. Both simulators use 100% of single core CPU. For a memory usage, QVM 
takes 7.2% and Qasm_simulator  takes 5.2% when computing the circuit. In the aspect of 
compiled programming language, moreover, the two simulators use different lanuguages. 
As described in Section 2.3, the python program for the Qasm_simulator  is compiled into a 
Qasm instruction set. The Qasm program is constructed from C++ programming language 
to computes on the Qasm_simulator . Differently, t he python program for the QVM  is 
compiled into a native Quilc. The native Quil program is constructed from Lisp 
programming language to be computed on the QVM . As mentioned, both of the quantum 
computer simulators are computed with the default configuration. Then, with the difference 
of underlying programming language of the simulator, the computing wall -time from the 
identical circuit on different platforms can be different .  
 
 
Figure 5.18 The computing wall -time from Qisk it and Rigetti quantum computer 
simulator  0.0930.2610.6371.42
11.395
114.1811617.95610908.271
020004000600080001000012000
00.20.40.60.811.21.41.6
4 qubits 5 qubits 6 qubits 7 qubitsComputing wall -time (second)
Size of qubit position stateAverage Computing wall -time
Qiskit common gates Rigetti common gates (Secondary Axis)41 
 
 
 5.1.5.3 Circuit Types Vs Circuit Depth and Computing Wall -time  
The circuit depths on each size of the one -dimensional quantum random walk are various 
as it depends on the depth of the conditional shift operator. In our experiments, 5 different 
types of conditional shift operators are used, including common quantum gates and 4 modes 
of MCT. However, the circuit depths of circuits that are made up of the common gates and 
run on the Qasm_simulator  and QVM  are equivalent because those circuits are identical. In 
this section, the discussion then focuses only on the results from Qasm_simulator  because 
MCT is a special function of Qiskit.  
Figures 5.19 â€“ 5.22 show the computed circuit depth (on the primary  vertical axis) and the 
computing wall -time (on the  secondary vertical axis ) of the 4- , 5-, 6-, and 7- qubit position 
state circuits, respectively. The circuit modes (on the horizontal axis) are sorted in an 
increasing order of the circuit depths, which are the same for all sizes of the position state, 
as: common gates (Toffoli -CNOT -NOT), MCT -Basic, MCT -Advanced, MCT -Basic -Dirty -
Ancilla, and MCT -NoAncilla. It can be observed that the computing wall -time tends to 
increase when the circuit depth is growing. However, on the 5- , 6-, and 7- qubit position 
state in  Figures 5.20 -5.21, the pair of computing wall -time and circuit depth from MCT -
Advanced and MCT -Basic -Dirty -Ancilla present a contradictory fashion. Even though the 
circuit depths of using MCT -Advance are smaller than those using the MCT -Basic -Dirty -
Ancilla, the MCT -Advanceâ€™s computing wall -times are longer than MCT -Basic -Dirty -
Ancilla.  
 
 
 
Figure 5.19 The circuit depth and computing wall -time of 4 -qubit position state for each 
type of conditional shift operator  99175225316 323
0.0930.1660.2070.2390.291
00.050.10.150.20.250.30.35
050100150200250300350
Computing Wall -timeCircuit Depth4-qubit position state
Circuit Depth Computing Wall-time42 
 
 
  
 
Figure 5.20 The circuit depth and computing wall -time of 5 -qubit position state for each 
type of conditional shift operator  
 
 
Figure 5.21 The circuit depth and computing wall -time of 6 -qubit position state for each 
type of conditional shift operator  
 2708851380 16051770
0.2610.5121.3741.2071.593
00.20.40.60.811.21.41.61.8
0200400600800100012001400160018002000
Computing Wall -TimeCircuit Depth5-qubit position state
Circuit Depth Computing Wall-time
6823317461961088370
0.637
1.3695.107
4.2347.473
012345678
0100020003000400050006000700080009000
Computing Wall -timeCircuit Depth6-qubit position state
Circuit Depth Computing Wall-time43 
 
 
  
 
Figure 5.22 The circuit depth and computing  wall-time of 7 -qubit position state for each 
type of conditional shift operator  
For further investigation, all the implemented circuits are transformed into a circuit that 
contains only a single -qubit (ğ‘ˆğ‘ˆ3) and two -qubits gate ( ğ¶ğ¶ğ¶ğ¶ğ¶ğ¶ğ¶ğ¶ ). According to Kobayashi  
[27], the quantum circuit can be reassembled into a circuit that contains only those 
fundamental gates. The transformations are done using a function provided by IBM .  
After the compilation and execution, the probability distribution from each circ uit type is 
similar to its previous version. However, the computing wall -time seems not to depend on 
the circuit depth. For example, in the four -qubit position state as displayed in Figure 5.23, 
the MCT -Basic -Dirty -Ancilla has more depth than the common- quantum -gate circuit, but 
the MCT -Basic -Dirty -Ancilla circuit spends less time in computation. The inconsistency 
also occurs in comparing other types of the circuit with each size of qubit position state as 
shown in Figures 5.24 â€“ 5.26. Note that the order of circuit modes on the horizontal axis is 
changed due to the circuit depth after unrolling the circuits .   
 16411065018840
1984836669
1.42 3.26819.17112.6530.537
05101520253035
0500010000150002000025000300003500040000
Computing Wall -timeCircuit Depth7-qubit position state44 
 
 
  
 
Figure 5.23 The circuit depth and computing wall -time of 4 -qubit position state for each 
type of conditional shift operator after unrolling the c ircuit  
 
 
 
Figure 5.24 The circuit depth and computing wall -time of 5 -qubit position state for each 
type of conditional shift operator after unrolling the circuit  346304 3813744370.33
0.2620.27 0.324 0.323
00.050.10.150.20.250.30.35
0200400600
Computing wall -timeCircuit Depth4-qubit position state (Unrolled)
Circuit Depth Computing Wall-time
1113129317431878
2763
1.199
0.8381.148
1.6162.06
00.511.522.5
050010001500200025003000
Computing wall -timeCircuit Depth5-qubit position state (Unrolled)
Circuit Depth Computing Wall-time45 
F
igure 5.25 The circuit depth and computing wall -time of 6 -qubit position state for each  
type of conditional shift operator after unrolling the circuit 
F
igure 5.26 The circuit depth and computing wall -time of 7 -qubit position state for each 
type of conditional shift operator after unrolling the circuit 32584436638985909489
3.3472.314.0637.2617.825
0123456789
010002000300040005000600070008000900010000
Computing Wall -timeCircuit Depth6-qubit position state (Unrolled)
Circuit Depth Computing Wall-time
857113485
204153711038433
8.9076.19613.48932.627
33.706
0510152025303540
050001000015000200002500030000350004000045000
Computing Wall -timeCircuit Depth7-qubit position state (Unrolled)
Circuit Depth Computing Wall-time46 
 
 
 5.1.5.4 Size of Qubit Position Stat e Vs Circuit Depth and Computing Wall -time (on 
different circuit Types)  
Instead of studying the relation between the circuit depth and the computing wall -time of 
the different circuit types, this section discusses another aspect of the that relation. The 
analysis of circuit depth and computing wall -time for the same type of conditional shift 
operator shows intriguing relation.  For the same type of conditional shift operator, the 
computing wall -time increases as the circuit depth is increasing as demonstrated in Figures 
5.27 â€“ 5.31. A curve fitting for each graph is also presented.  
From the graph fittings, both the computing wall -time and the circuit depth from the circuit 
that constructed from Toffoli -CNOT -NOT show a positive polynomial trend with the 
chang e in number of qubits position state. For the MCT -Advanced and MCT -NoAncilla, 
both the computing wall -time and the circuit depth present an exponential growth with the 
change in number of qubits position state. For the MCT -Basic and MCT -Basic -Dirty -
Ancilla , the number of qubits position state has a positive polynomial trend with the 
computing wall -time, while having an increasing exponential trend with the circuit depth.  
It can then be concluded that when the number of qubits position state increases, the circuit  
constructed from Toffoli -CNOT -NOT will have the lowest amount of both computing wall -
time and circuit depth acco rding to their polynomial trends.  
 
 
 
Figure 5.27 The circuit depth and computing wall -time of Toffili- CNOT -NOT conditional 
shift opera tor for each size of qubit position state  
 992706821641
0.093
0.2610.6371.42
RÂ² = 0.9967RÂ² = 0.9981
00.511.5
0500100015002000
4 Qbits 5 Qbits 6 Qbits 7 Qbits
Computing Wall -timeCircuit DepthToffoli -CNOT -NOT before unrolled
Circuit Depth Computing Wall-time
Poly. (Circuit Depth) Poly. (Computing Wall-time)47 
 
 
  
 
Figure 5.28 The circuit depth and computing wall -time of MCT -Basic conditional shift 
operator for each size of qubit position state  
 
 
 
Figure 5.29 The circuit depth and computing wall -time of MCT -Basic -Dirty -Ancilla 
conditional shift operator for each size of qubit position state  175885331710650
0.1660.5121.3693.268
RÂ² = 0.9944RÂ² = 0.9976
00.511.522.533.5
02000400060008000100001200014000
4 Qbits 5 Qbits 6 Qbits 7 Qbits
Computing Wall -timeCircuit DepthMCT -Basic
Circuit Depth Computing Wall-time
Expon. (Circuit Depth) Poly. (Computing Wall-time)
316
1605610819848
0.2391.2074.23412.65
RÂ² = 0.9947RÂ² = 0.9942
02468101214
02000400060008000100001200014000160001800020000
4 Qbits 5 Qbits 6 Qbits 7 Qbits
Computing Wall -timeCircuit DepthMCT -Basic -Dirty -Ancilla
Circuit Depth Computing Wall-time
Expon. (Circuit Depth) Poly. (Computing Wall-time)48 
F
igure 5.30 The circuit depth and computing wall -time of MCT -Advanced conditional shift 
operator for each size of qubit position state 
F
igure 5.31 The circuit depth and computing wall -time of MCT -NoAncilla conditional shift 
operator for each size of qubit position state 2251380461918840
0.2071.3745.10719.171 RÂ² = 0.993
RÂ² = 0.9912
05101520
0500010000150002000025000
4 Qbits 5 Qbits 6 Qbits 7 Qbits
Computing Wall -timeCircuit DepthMCT -Advanced
Circuit Depth Computing Wall-time
Expon. (Circuit Depth) Expon. (Computing Wall-time)
3231770837036669
0.291
1.5937.47330.537
RÂ² = 0.999RÂ² = 0.9982
05101520253035
050001000015000200002500030000350004000045000
4 Qbits 5 Qbits 6 Qbits 7 Qbits
Computing Wall -timeCircuit DepthMCT -NoAncilla
Circuit Depth Computing Wall-time
Expon. (Circuit Depth) Expon. (Computing Wall-time)49 
5
.1.5.5 The relation between computing wall -time and circuit depth  
In this section, the relationships between circuit depth and computing wall -time are 
analyzed . As illustrated in Figure 5.32, it can be obviously seen that the computing wall -
time and circuit depth have a linear relationship. The increasing rates, however, are different 
for each type of conditional shift operator. An increasing rate value presents  the growth of 
the computing wall -time when the circuit depth is increasing, as shown in Table 5.5. For the 
same size of qubit position state, MCT -Advanced is the type that has more circuit depth and 
computing wall -time. However, the increasing rate is equ al to the MCT -NoAncilla. The 
highest increasing rate among all types is the circuit constructed with Toffoli- CNOT -NOT. 
Nonetheless, for the same size of qubit position state, the circuit with Toffoli- CNOT -NOT, 
still takes less time than other type of conditional shift operator. 
F
igure 5.32 The conclusion of a relation between circuit depth and computing wall -time 
for each type of conditional shift operator 0510152025303540
0 5000 10000 15000 20000 25000 30000 35000 40000 45000Computing wall -time
Circuit Depth
Toffoli-CNOT-NOT MCT-Basic MCT-Basic-Dirty-Ancilla
MCT-Advanced MCT-NoAncilla50 
 
 
 Table 5.5 The increasing rate of the computing wall -time from the circuit depth in Figure 
5.32 
 
Circuit types  Computing wall -time increasing rate  from  
the Circuit depth  
Toffoli -CNOT -NOT  0.001  
MCT -Basic  0.0005  
MCT -Basic -Dirty -Ancilla  0.0007  
MCT -Advanced  0.0009  
MCT -NoAncilla  0.0009  
 
5.2  A Quantum Random Walk Computing on Quantum Computer  
In this experiment, 4 different sizes of quantum random walk circuits, which are including 
4, 5, 6, and 7 qubits position state, are computed on the real IBMâ€™s quantum computer, 
named IBM_Q_16_Melbourne . The objective of this study is to find a possibility to c ompute 
quantum circuits on the actual quantum computer.   
The circuits in this experiment are identical to those in Section 5.1. T he 5 different shift 
operator settings including common quantum gate, MCT -basic, MCT -basic -dirty -ancilla, 
MCT -advanced, and MC T-noancilla, are adopted. The coin operator is the Hadamard 
operator. The measurement operators are placed at the last operator on each qubit position 
state. The measurement shots are 8192, which is the maximum number of ther measurement 
shots from  IBM_Q_1 6_Melbourne. The walking steps for the circuit with 4, 5, 6, and 7 
qubits position states are 7, 15, 31, and 63, respectively.  
 51 
F
igure 5.33 The probability distribution of four -qubits positi on state from each 
computation  
T
o compute on ibm_q_16_melbourne , all circuits are submitted to the quantum computer 
by Qiskitâ€™s framework. The measurement results are then returned and the probability 
distribution from the measur ement results was collected and displayed . As shown in Figure 
5.33, blue line  represents  the probability distribution from ibm_q_16_melbourne , red line  
represents the probability distribution from quantum computer simulator without noise model, grey line represents the probability distribution from quantum computer simulator 
with noise model and 8192 measurement shots, orange line  represents the probability 
distribution from quantum computer simulator with noise model and 100 million measurement shots.  However, only the measurement results from the 4- qubits position state 
are returned from the  computation, while the other circuitâ€™s size return the 8020 error code. 
According to Qiskitâ€™s document, the error 8020 is related to a longer circuit depth than the 
quantum computer's capability.  
As illustrated in Figure 5.33, the returned probability distribution (the blue line) from 
ibm_q_16_melbourne  is inconsistent with the results from the simulator (the red line). The 
inconsistency could come from the noise that occurred in the real quantum computer 00.050.10.150.20.25
-7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8Probability distribution from MCT -Basic computed on 
IBMQ_16_Melbourne VS Simulator
IBMQ_16_Melbourne Simulator Noise-Model-8192 Noise-Model-100M52 
ope
ration. To investigate further, the ibm_q_16_melbourne â€™s noise model was imported into 
Qasm_simulator . The circuits are computed again with 8,192 measurement shots. The 
probability distribution from the results (the grey line) is, however, still similar to the 
distribution from ibm_q_16_melbourne . Then, the measurement shots are increased to 100 
million. The probability distribution is still in the same manner.  Therefore, it might be 
concluded that noise is the variable that makes the probability distribution from the quantum 
computer different from the simulator.  CHAPTER 6 CONCLUSION  
Q
uantum computing is one of the solutions that might break the limitation of computational 
power. Many quantum algorithms have been invented. Some of them have proved to be better 
than the classical algorithms when so lving the same size and complexity of problems. In 
quantum computing, qubits are used to store information. A qubit can be in |0âŸ©, |1âŸ©, or the 
superposition state. Moreover, the multiple qubits can be joined together by a tensor product. The measuremen t operator can be applied to acquire the state of the qubit.  After the 
measurement, the state of qubit will be projected to the measurement basis. To process 
qubitâ€™s information, a unitary transformation can be performed by employing quantum gates 
to qubits. For more complex computations, a collection of quantum gates can be used to 
construct a quantum circuit.  
F
or quantum computing devices, several technologies can be used to construct a quantum 
processing unit. In this thesis, the computation are performed on the quantum devices using 
superconducting technology from IBM and Rigetti. These two companies have quantum 
processing units that are publicly available to researchers and also have complete  documents. 
Moreover, the two companies provide an SDK to communicate between a programming 
language and the quantum processing unit. Qiskit and Forest are the quantum computing 
SDK provided by IBM and Rigetti respectively.   
A
ccording to the literature, a quantum random walk is an analog to the classical random  
walk, which can be a tool to construct many other quantum algorithms. The shift operator is 
a significant part of the quantum random walk that operates to move the walker position. To 
construct a shift operator, the quantum circuit, which can operate as a n incrementor and 
decrementer, is designed. The special function from IBMâ€™ Qiskit is explored as an alternative 
shift operator construction. 
I
n this thesis, the one -dimensional quantum random walk algorithm is studied . The walking 
space, coin, and shift operators of the one-dimensional quantum random walk are analyzed . 
After that , the circuit of the one -dimensional quantum random walk is implemented . The 
shift operator  is inspired by the incrementer circuit proposed by  Li, et al. in 2013. Moreover, 
the different shift operators are constructed using  Qiskitâ€™s  MCT function with 4 distinct  
modes, namely Basic, Basic- Dirty -Ancilla, Advanced, and No Ancilla . Then, our shift 
operator s are verified  by setting up a quantum random walk calculation. The probability 
distribution s obtained  from testing the shift operator s were consistent with one in the research 
paper by  Kempe in 2003. 54 
T
he benchmarking in IBM and Rigettiâ€™s quantum computer simulators are performed using 
the implemented quantum random walk circuit. The benchmark uses 4 sizes of the one -
dimensional quantum random walk. For the equivalent position state size, the results show 
that they are not significantly different in the probability distributions measured from the two quantum computer simulators and four  modes of the MCT function. For the computing wall -
time, the results
 demonstrate that the computing wall -time depends on the circuit depth. 
However, even with the identical circuit depth, the computing wall -time on the different 
quantum computer simulators  can be contrasted. From multiple trials, the results show that 
the computing wall -time of IBMâ€™s quantum computer simulator is significantly less than 
Rigettiâ€™s.  Both quantum computer simulators are operated with the binary execution; 
therefore, the actual  cause that accounts for the difference cannot be accurately defined .  
The relationship between circuit depth and the number of qubits position state is observed on IBMâ€™s quantum computer simulator. The circuit depths are exponentially increasing except fo r the circuit constructed by Toffoli -CNOT -NOT that is rising in polynomial trend, 
when the number of qubits position state grows. Moreover, the relationship between 
computing wall -time and the number of qubit position state are investigated. The results 
show that the computing wall -times of Toffoli- CNOT -NOT, MCT -Basic and MCT -Basic -
Dirty -Ancilla are increasing in a polynomial trend when the number of qubits position state 
is growing. Also, the circuit that has a larger depth spends a longer computing wall -time than 
a smaller one. Furthermore, the linear relationships between computing wall -time and circuit 
depth are examined. The circuit with MCT -Basic takes shorter computing wall -time when 
the circuit depth is increased. In contrast, the circuit with Toffol i-CNOT -NOT takes longer 
computing wall -time when the circuit depth is increased. However, for the same size of qubit 
position state, the circuit with Toffoli- CNOT -NOT, has the smallest depth and takes the least 
time than the other types of conditional shift operators. 
Finally, an other experiment  is conducted to compare the circuit comput ed on 
Qasm_simulator  and ibmq_16_melbourne . The acquired probability distributions are 
different , which could be the effect of the noise. The ibmq_16_melbourne â€™s noise model  is 
imported to Qasm_simulator  to confirmed that ibmq_16_melbourne is  disturbed by  the 
noise.  